<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lingmoumou.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。  简介设计模式(英语 design pattern)是对面向对象设计中反复出现的问题的解决方案。这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的">
<meta name="keywords" content="java,design patterns">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式简介">
<meta property="og:url" content="https://lingmoumou.github.io/p/2020/02/05/8a7312b/index.html">
<meta property="og:site_name" content="Lingmoumou&#39;s Blog">
<meta property="og:description" content="软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。  简介设计模式(英语 design pattern)是对面向对象设计中反复出现的问题的解决方案。这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-01-31T13:53:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式简介">
<meta name="twitter:description" content="软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。  简介设计模式(英语 design pattern)是对面向对象设计中反复出现的问题的解决方案。这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的">

<link rel="canonical" href="https://lingmoumou.github.io/p/2020/02/05/8a7312b/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>设计模式简介 | Lingmoumou's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lingmoumou's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">きっといつかって愿うまま</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lingmoumou.github.io/p/2020/02/05/8a7312b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ling Moumou">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lingmoumou's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式简介
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-05 18:08:10" itemprop="dateCreated datePublished" datetime="2020-02-05T18:08:10+08:00">2020-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-31 21:53:26" itemprop="dateModified" datetime="2021-01-31T21:53:26+08:00">2021-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TODO/" itemprop="url" rel="index"><span itemprop="name">TODO</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TODO/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TODO/Java/Design-Patterns/" itemprop="url" rel="index"><span itemprop="name">Design Patterns</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>设计模式(英语 design pattern)是对面向对象设计中<strong>反复出现的问题</strong>的解决方案。这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的。这个术语的含义还存有争议。算法不是设计模式，因为算法致力于解决问题而非设计问题。设计模式通常描述了一组相互紧密作用的类与对象。设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标。</p>
<h3 id="什么是-GOF（四人帮，全拼-Gang-of-Four）？"><a href="#什么是-GOF（四人帮，全拼-Gang-of-Four）？" class="headerlink" title="什么是 GOF（四人帮，全拼 Gang of Four）？"></a>什么是 GOF（四人帮，全拼 Gang of Four）？</h3><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。</p>
<p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li><strong>对接口编程而不是对实现编程</strong>。</li>
<li><strong>优先使用对象组合而不是继承</strong>。</li>
</ul>
<a id="more"></a>
<h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><p>软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。<br><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/Q20200205213002.png" alt="软件模式基本结构"></p>
<ol>
<li>模式名称<br>每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</li>
<li>问题<br>问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</li>
<li>解决方案<br>模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。</li>
<li>效果<br>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。</li>
</ol>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><table>
<thead>
<tr>
<th style="text-align:left">设计原则名称</th>
<th style="text-align:left">定 义</th>
<th style="text-align:center">使用频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="#开闭原则">开闭原则 (Open-Closed Principle, OCP)</a></td>
<td style="text-align:left">软件实体应对扩展开放，而对修改关闭</td>
<td style="text-align:center">★★★★★</td>
</tr>
<tr>
<td style="text-align:left"><a href="#单一职责原则">单一职责原则 (Single Responsibility Principle, SRP)</a></td>
<td style="text-align:left">一个类只负责一个功能领域中的相应职责</td>
<td style="text-align:center">★★★★☆</td>
</tr>
<tr>
<td style="text-align:left"><a href="#里氏代换原则">里氏代换原则 (Liskov Substitution Principle, LSP)</a></td>
<td style="text-align:left">所有引用基类对象的地方能够透明地使用其子类的对象</td>
<td style="text-align:center">★★★★★</td>
</tr>
<tr>
<td style="text-align:left"><a href="#依赖倒转原则">依赖倒转原则 (Dependence Inversion Principle, DIP)</a></td>
<td style="text-align:left">抽象不应该依赖于细节，细节应该依赖于抽象</td>
<td style="text-align:center">★★★★★</td>
</tr>
<tr>
<td style="text-align:left"><a href="#接口隔离原则">接口隔离原则 (Interface Segregation Principle, ISP)</a></td>
<td style="text-align:left">使用多个专门的接口，而不使用单一的总接口</td>
<td style="text-align:center">★★☆☆☆</td>
</tr>
<tr>
<td style="text-align:left"><a href="#迪米特法则">迪米特法则 (Law of Demeter, LoD)或称最少知识原则(Least Knowledge Principle，LKP)</a></td>
<td style="text-align:left">一个软件实体应当尽可能少地与其他实体发生相互作用</td>
<td style="text-align:center">★★★☆☆</td>
</tr>
<tr>
<td style="text-align:left"><a href="#合成复用原则">合成复用原则 (Composite Reuse Principle, CRP)</a></td>
<td style="text-align:left">尽量使用对象组合，而不是继承来达到复用的目的</td>
<td style="text-align:center">★★★★☆</td>
</tr>
</tbody>
</table>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则就是说对扩展开放，对修改关闭。当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下：</p>
<ul>
<li>对软件测试的影响<br>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</li>
<li>可以提高代码的可复用性<br>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</li>
<li>可以提高软件的可维护性<br>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</li>
</ul>
<p>可以通过“<strong>抽象约束、封装变化</strong>“来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。<br>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<p><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/page_3.png" alt="某CRM中客户信息图形统计模块"></p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。单一职责原则的核心就是控制类的粒度大小、<strong>将对象解耦、提高其内聚性</strong>。如果遵循单一职责原则将有以下优点：</p>
<ul>
<li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li>
<li>提高类的可读性。复杂性降低，自然其可读性会提高。</li>
<li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li>
<li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>
<p>单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p>
<p><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/page_2.png" alt="某CRM中客户信息图形统计模块"></p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。具体来说，其作用如下：</p>
<ul>
<li>里氏替换原则是实现开闭原则的重要方式之一。</li>
<li>它克服了继承中重写父类造成的可复用性变差的缺点。</li>
<li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>
</ul>
<p>里氏替换原则通俗来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<ul>
<li>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</li>
<li>如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</li>
</ul>
<p><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/page_4.png" alt="某CRM中客户信息图形统计模块"></p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。具体来说，其作用如下：</p>
<ul>
<li>依赖倒置原则可以降低类间的耦合性。</li>
<li>依赖倒置原则可以提高系统的稳定性。</li>
<li>依赖倒置原则可以减少并行开发引起的风险。</li>
<li>依赖倒置原则可以提高代码的可读性和可维护性。</li>
</ul>
<p>依赖倒置原则的目的是通过要<strong>面向接口</strong>的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下几点，就能在项目中满足这个规则。</p>
<ul>
<li>每个类尽量提供接口或抽象类，或者两者都具备。</li>
<li>变量的声明类型尽量是接口或者是抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>使用继承时尽量遵循里氏替换原则。</li>
</ul>
<p><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/page_5.png" alt="某CRM中客户信息图形统计模块"></p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p>
<blockquote>
<p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p>
<ul>
<li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li>
<li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li>
</ul>
</blockquote>
<p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下5个优点：</p>
<ul>
<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>
<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>
<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li>
<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li>
</ul>
<p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</p>
<ul>
<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>
<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>
<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
<p><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/page_6.png" alt="某CRM中客户信息图形统计模块"></p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点:</p>
<ul>
<li>降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li>
</ul>
<p><em>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</em></p>
<p>在运用迪米特法则时要注意以下几点：</p>
<ul>
<li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li>
<li>在类的结构设计上，尽量降低类成员的访问权限。</li>
<li>在类的设计上，优先考虑将一个类设置成不变类。</li>
<li>在对其他类的引用上，将引用其他对象的次数降到最低。</li>
<li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li>
<li>谨慎使用序列化（Serializable）功能。</li>
</ul>
<p><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/page_7.png" alt="某CRM中业务操作窗口模块"></p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>合成复用原则又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先<strong>使用组合或者聚合等关联关系</strong>来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p>
<blockquote>
<p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
</blockquote>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。</p>
<ul>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ul>
<p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>
<p><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/page_8.png" alt="某CRM中客户信息图形统计模块"></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img data-src="https://lingmoumou-blog.oss-cn-beijing.aliyuncs.com/blog/8a7312b/1354152786_2931.jpg" alt="设计模式之间的关系"></p>
<h3 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h3><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<p>创建型模式分为以下几种。</p>
<ul>
<li><strong>单例（Singleton）模式</strong>：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li><strong>原型（Prototype）模式</strong>：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li><strong>工厂方法（FactoryMethod）模式</strong>：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li><strong>抽象工厂（AbstractFactory）模式</strong>：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li><strong>建造者（Builder）模式</strong>：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<p>以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。</p>
<h4 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h4><blockquote>
<p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p>
</blockquote>
<h4 id="原型模式（Prototype-Pattern）"><a href="#原型模式（Prototype-Pattern）" class="headerlink" title="原型模式（Prototype Pattern）"></a>原型模式（Prototype Pattern）</h4><h4 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h4><h4 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h4><h4 id="建造者模式（Builder-Pattern）"><a href="#建造者模式（Builder-Pattern）" class="headerlink" title="建造者模式（Builder Pattern）"></a>建造者模式（Builder Pattern）</h4><h3 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h3><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。<br>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ul>
<li><strong>代理（Proxy）模式</strong>：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li><strong>适配器（Adapter）模式</strong>：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li><strong>桥接（Bridge）模式</strong>：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li><strong>装饰（Decorator）模式</strong>：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li><strong>外观（Facade）模式</strong>：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li><strong>享元（Flyweight）模式</strong>：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li><strong>组合（Composite）模式</strong>：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ul>
<p>以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。</p>
<h4 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h4><h4 id="桥接模式（Bridge-Pattern）"><a href="#桥接模式（Bridge-Pattern）" class="headerlink" title="桥接模式（Bridge Pattern）"></a>桥接模式（Bridge Pattern）</h4><h4 id="过滤器模式（Filter、Criteria-Pattern）"><a href="#过滤器模式（Filter、Criteria-Pattern）" class="headerlink" title="过滤器模式（Filter、Criteria Pattern）"></a>过滤器模式（Filter、Criteria Pattern）</h4><h4 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h4><h4 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h4><h4 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h4><h4 id="享元模式（Flyweight-Pattern）"><a href="#享元模式（Flyweight-Pattern）" class="headerlink" title="享元模式（Flyweight Pattern）"></a>享元模式（Flyweight Pattern）</h4><h4 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h4><h3 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h3><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。</p>
<ul>
<li><strong>模板方法（Template Method）模式</strong>：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li><strong>策略（Strategy）模式</strong>：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li><strong>命令（Command）模式</strong>：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li><strong>职责链（Chain of Responsibility）模式</strong>：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li><strong>状态（State）模式</strong>：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li><strong>观察者（Observer）模式</strong>：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li><strong>中介者（Mediator）模式</strong>：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li><strong>迭代器（Iterator）模式</strong>：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li><strong>访问者（Visitor）模式</strong>：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li><strong>备忘录（Memento）模式</strong>：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li><strong>解释器（Interpreter）模式</strong>：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ul>
<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式，下面我们将详细介绍它们的特点、结构与应用。</p>
<h4 id="责任链模式（Chain-of-Responsibility-Pattern）"><a href="#责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="责任链模式（Chain of Responsibility Pattern）"></a>责任链模式（Chain of Responsibility Pattern）</h4><h4 id="命令模式（Command-Pattern）"><a href="#命令模式（Command-Pattern）" class="headerlink" title="命令模式（Command Pattern）"></a>命令模式（Command Pattern）</h4><h4 id="解释器模式（Interpreter-Pattern）"><a href="#解释器模式（Interpreter-Pattern）" class="headerlink" title="解释器模式（Interpreter Pattern）"></a>解释器模式（Interpreter Pattern）</h4><h4 id="迭代器模式（Iterator-Pattern）"><a href="#迭代器模式（Iterator-Pattern）" class="headerlink" title="迭代器模式（Iterator Pattern）"></a>迭代器模式（Iterator Pattern）</h4><h4 id="中介者模式（Mediator-Pattern）"><a href="#中介者模式（Mediator-Pattern）" class="headerlink" title="中介者模式（Mediator Pattern）"></a>中介者模式（Mediator Pattern）</h4><h4 id="备忘录模式（Memento-Pattern）"><a href="#备忘录模式（Memento-Pattern）" class="headerlink" title="备忘录模式（Memento Pattern）"></a>备忘录模式（Memento Pattern）</h4><h4 id="观察者模式（Observer-Pattern）"><a href="#观察者模式（Observer-Pattern）" class="headerlink" title="观察者模式（Observer Pattern）"></a>观察者模式（Observer Pattern）</h4><h4 id="状态模式（State-Pattern）"><a href="#状态模式（State-Pattern）" class="headerlink" title="状态模式（State Pattern）"></a>状态模式（State Pattern）</h4><h4 id="空对象模式（Null-Object-Pattern）"><a href="#空对象模式（Null-Object-Pattern）" class="headerlink" title="空对象模式（Null Object Pattern）"></a>空对象模式（Null Object Pattern）</h4><h4 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h4><h4 id="模板模式（Template-Pattern）"><a href="#模板模式（Template-Pattern）" class="headerlink" title="模板模式（Template Pattern）"></a>模板模式（Template Pattern）</h4><h4 id="访问者模式（Visitor-Pattern）"><a href="#访问者模式（Visitor-Pattern）" class="headerlink" title="访问者模式（Visitor Pattern）"></a>访问者模式（Visitor Pattern）</h4><h3 id="J2EE-模式"><a href="#J2EE-模式" class="headerlink" title="J2EE 模式"></a>J2EE 模式</h3><h4 id="MVC-模式（MVC-Pattern）"><a href="#MVC-模式（MVC-Pattern）" class="headerlink" title="MVC 模式（MVC Pattern）"></a>MVC 模式（MVC Pattern）</h4><h4 id="业务代表模式（Business-Delegate-Pattern）"><a href="#业务代表模式（Business-Delegate-Pattern）" class="headerlink" title="业务代表模式（Business Delegate Pattern）"></a>业务代表模式（Business Delegate Pattern）</h4><h4 id="组合实体模式（Composite-Entity-Pattern）"><a href="#组合实体模式（Composite-Entity-Pattern）" class="headerlink" title="组合实体模式（Composite Entity Pattern）"></a>组合实体模式（Composite Entity Pattern）</h4><h4 id="数据访问对象模式（Data-Access-Object-Pattern）"><a href="#数据访问对象模式（Data-Access-Object-Pattern）" class="headerlink" title="数据访问对象模式（Data Access Object Pattern）"></a>数据访问对象模式（Data Access Object Pattern）</h4><h4 id="前端控制器模式（Front-Controller-Pattern）"><a href="#前端控制器模式（Front-Controller-Pattern）" class="headerlink" title="前端控制器模式（Front Controller Pattern）"></a>前端控制器模式（Front Controller Pattern）</h4><h4 id="拦截过滤器模式（Intercepting-Filter-Pattern）"><a href="#拦截过滤器模式（Intercepting-Filter-Pattern）" class="headerlink" title="拦截过滤器模式（Intercepting Filter Pattern）"></a>拦截过滤器模式（Intercepting Filter Pattern）</h4><h4 id="服务定位器模式（Service-Locator-Pattern）"><a href="#服务定位器模式（Service-Locator-Pattern）" class="headerlink" title="服务定位器模式（Service Locator Pattern）"></a>服务定位器模式（Service Locator Pattern）</h4><h4 id="传输对象模式（Transfer-Object-Pattern）"><a href="#传输对象模式（Transfer-Object-Pattern）" class="headerlink" title="传输对象模式（Transfer Object Pattern）"></a>传输对象模式（Transfer Object Pattern）</h4><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[^3]：<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2117635?fromtitle=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;fromid=1212549&amp;fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2117635?fromtitle=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&amp;fromid=1212549&amp;fr=aladdin</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Ling Moumou
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lingmoumou.github.io/p/2020/02/05/8a7312b/" title="设计模式简介">https://lingmoumou.github.io/p/2020/02/05/8a7312b/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/design-patterns/" rel="tag"># design patterns</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/p/2020/02/03/635b5af8/" rel="prev" title="Spring Security 记住我">
      <i class="fa fa-chevron-left"></i> Spring Security 记住我
    </a></div>
      <div class="post-nav-item">
    <a href="/p/2020/02/06/2dc6b46a/" rel="next" title="控制反转（IoC）、依赖注入（DI）、依赖查找（DL）">
      控制反转（IoC）、依赖注入（DI）、依赖查找（DL） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-GOF（四人帮，全拼-Gang-of-Four）？"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 GOF（四人帮，全拼 Gang of Four）？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本要素"><span class="nav-number">2.</span> <span class="nav-text">基本要素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计原则"><span class="nav-number">3.</span> <span class="nav-text">设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#开闭原则"><span class="nav-number">3.1.</span> <span class="nav-text">开闭原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单一职责原则"><span class="nav-number">3.2.</span> <span class="nav-text">单一职责原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#里氏代换原则"><span class="nav-number">3.3.</span> <span class="nav-text">里氏代换原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖倒转原则"><span class="nav-number">3.4.</span> <span class="nav-text">依赖倒转原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口隔离原则"><span class="nav-number">3.5.</span> <span class="nav-text">接口隔离原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迪米特法则"><span class="nav-number">3.6.</span> <span class="nav-text">迪米特法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合成复用原则"><span class="nav-number">3.7.</span> <span class="nav-text">合成复用原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分类"><span class="nav-number">4.</span> <span class="nav-text">分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建型模式（Creational-Patterns）"><span class="nav-number">4.1.</span> <span class="nav-text">创建型模式（Creational Patterns）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单例模式（Singleton-Pattern）"><span class="nav-number">4.1.1.</span> <span class="nav-text">单例模式（Singleton Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型模式（Prototype-Pattern）"><span class="nav-number">4.1.2.</span> <span class="nav-text">原型模式（Prototype Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工厂模式（Factory-Pattern）"><span class="nav-number">4.1.3.</span> <span class="nav-text">工厂模式（Factory Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象工厂模式（Abstract-Factory-Pattern）"><span class="nav-number">4.1.4.</span> <span class="nav-text">抽象工厂模式（Abstract Factory Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建造者模式（Builder-Pattern）"><span class="nav-number">4.1.5.</span> <span class="nav-text">建造者模式（Builder Pattern）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构型模式（Structural-Patterns）"><span class="nav-number">4.2.</span> <span class="nav-text">结构型模式（Structural Patterns）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#适配器模式（Adapter-Pattern）"><span class="nav-number">4.2.1.</span> <span class="nav-text">适配器模式（Adapter Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#桥接模式（Bridge-Pattern）"><span class="nav-number">4.2.2.</span> <span class="nav-text">桥接模式（Bridge Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过滤器模式（Filter、Criteria-Pattern）"><span class="nav-number">4.2.3.</span> <span class="nav-text">过滤器模式（Filter、Criteria Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合模式（Composite-Pattern）"><span class="nav-number">4.2.4.</span> <span class="nav-text">组合模式（Composite Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器模式（Decorator-Pattern）"><span class="nav-number">4.2.5.</span> <span class="nav-text">装饰器模式（Decorator Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外观模式（Facade-Pattern）"><span class="nav-number">4.2.6.</span> <span class="nav-text">外观模式（Facade Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#享元模式（Flyweight-Pattern）"><span class="nav-number">4.2.7.</span> <span class="nav-text">享元模式（Flyweight Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代理模式（Proxy-Pattern）"><span class="nav-number">4.2.8.</span> <span class="nav-text">代理模式（Proxy Pattern）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行为型模式（Behavioral-Patterns）"><span class="nav-number">4.3.</span> <span class="nav-text">行为型模式（Behavioral Patterns）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#责任链模式（Chain-of-Responsibility-Pattern）"><span class="nav-number">4.3.1.</span> <span class="nav-text">责任链模式（Chain of Responsibility Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命令模式（Command-Pattern）"><span class="nav-number">4.3.2.</span> <span class="nav-text">命令模式（Command Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解释器模式（Interpreter-Pattern）"><span class="nav-number">4.3.3.</span> <span class="nav-text">解释器模式（Interpreter Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器模式（Iterator-Pattern）"><span class="nav-number">4.3.4.</span> <span class="nav-text">迭代器模式（Iterator Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中介者模式（Mediator-Pattern）"><span class="nav-number">4.3.5.</span> <span class="nav-text">中介者模式（Mediator Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#备忘录模式（Memento-Pattern）"><span class="nav-number">4.3.6.</span> <span class="nav-text">备忘录模式（Memento Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#观察者模式（Observer-Pattern）"><span class="nav-number">4.3.7.</span> <span class="nav-text">观察者模式（Observer Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态模式（State-Pattern）"><span class="nav-number">4.3.8.</span> <span class="nav-text">状态模式（State Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空对象模式（Null-Object-Pattern）"><span class="nav-number">4.3.9.</span> <span class="nav-text">空对象模式（Null Object Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#策略模式（Strategy-Pattern）"><span class="nav-number">4.3.10.</span> <span class="nav-text">策略模式（Strategy Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模板模式（Template-Pattern）"><span class="nav-number">4.3.11.</span> <span class="nav-text">模板模式（Template Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问者模式（Visitor-Pattern）"><span class="nav-number">4.3.12.</span> <span class="nav-text">访问者模式（Visitor Pattern）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#J2EE-模式"><span class="nav-number">4.4.</span> <span class="nav-text">J2EE 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC-模式（MVC-Pattern）"><span class="nav-number">4.4.1.</span> <span class="nav-text">MVC 模式（MVC Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#业务代表模式（Business-Delegate-Pattern）"><span class="nav-number">4.4.2.</span> <span class="nav-text">业务代表模式（Business Delegate Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合实体模式（Composite-Entity-Pattern）"><span class="nav-number">4.4.3.</span> <span class="nav-text">组合实体模式（Composite Entity Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据访问对象模式（Data-Access-Object-Pattern）"><span class="nav-number">4.4.4.</span> <span class="nav-text">数据访问对象模式（Data Access Object Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前端控制器模式（Front-Controller-Pattern）"><span class="nav-number">4.4.5.</span> <span class="nav-text">前端控制器模式（Front Controller Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拦截过滤器模式（Intercepting-Filter-Pattern）"><span class="nav-number">4.4.6.</span> <span class="nav-text">拦截过滤器模式（Intercepting Filter Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务定位器模式（Service-Locator-Pattern）"><span class="nav-number">4.4.7.</span> <span class="nav-text">服务定位器模式（Service Locator Pattern）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输对象模式（Transfer-Object-Pattern）"><span class="nav-number">4.4.8.</span> <span class="nav-text">传输对象模式（Transfer Object Pattern）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">5.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ling Moumou</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">82</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ling Moumou</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">
  

  

  

    </div>
</body>
</html>
